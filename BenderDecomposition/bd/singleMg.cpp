#include "IncludeDataFunction.h"



double singleMG() {



	int T = 24;


	int* gridbuy = new int[T] { 90, 90, 90, 90, 90, 90, 110, 110, 110, 110, 110, 125, 125, 125, 125, 125, 125, 125, 110, 110, 110, 110, 110, 110 };  //buying price from grid w.r.t time
	int* gridsell = new int[T] { 70, 70, 70, 70, 70, 70, 90, 90, 90, 90, 90, 105, 105, 105, 105, 105, 105, 105, 90, 90, 90, 90, 90, 90}; //selling price to grid w.r.t time

	float* Rdg1 = new float[T] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 15, 20, 23, 28, 33, 35, 34, 31, 28, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }; //Power generated by PV w.r.t time
	float* Rdg2 = new float[T] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 15, 20, 23, 28, 33, 35, 34, 31, 28, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }; //Power generated by PV w.r.t time

	float* Eload = new float[T] {169, 175, 179, 171, 181, 172, 270, 264, 273, 281, 193, 158, 161, 162, 250, 260, 267, 271, 284, 167, 128, 134, 144, 150};  //Electicity demand w.r.t tim



	int chgeff = 0.95;
	int diseff = 0.95;


	IloEnv env;
	IloModel model(env);

#pragma region Decision Variables

	IloNumVarArray Pgridbuy(env, T, 0, IloInfinity);
	IloNumVarArray Pgridsell(env, T, 0, IloInfinity);

	IloNumVarArray Pch(env, T, 0, IloInfinity);
	IloNumVarArray Pdis(env, T, 0, IloInfinity);
	IloNumVarArray Psoc(env, T, 0, 1);
	IloNumVarArray Pdg1(env, T, 0, 80); //DGA power generation range
	IloNumVarArray Pdg2(env, T, 0, 100); //DGA power generation range

#pragma endregion

#pragma region Objective Function

	IloExpr obj(env);

	for (int t = 0; t < T; t++) {
		obj += 80 * Pdg1[t] + 90 * Pdg2[t] + gridbuy[t] * Pgridbuy[t] - gridsell[t] * Pgridsell[t];
	}

	model.add(IloMinimize(env, obj));

#pragma endregion


#pragma region Constraints

	// Power Balance
	for (int t = 0; t < T; t++) {
		model.add(Pgridbuy[t]   + Rdg1[t] + Rdg2[t] + Pdis[t] - Pch[t] - Pgridsell[t] == Eload[t]);
	}


	//// SOC
	for (int t = 0; t < T; t++) {

		model.add(0 <= Pdg1[t]);
		model.add(Pdg1[t] <= 80);

		model.add(0 <= Pdg2[t]);
		model.add(Pdg2[t] <= 90);

		model.add(Psoc[t] <= 1);
		model.add(0 <= Psoc[t]);

		if (t == 0) {

			model.add(Psoc[t] == 0.2+ (Pch[t] * chgeff - Pdis[t] / diseff )/200 );

			model.add(Pch[t] <= 0.2 * 200 /chgeff );
			model.add(Pdis[t] <= (1 - 0.2) * 200 * diseff);

		}

		else {
			model.add(Psoc[t] == Psoc[t - 1] + (Pch[t] * chgeff - Pdis[t] / diseff) / 200);
			model.add(Pch[t] <= (Psoc[t - 1] * 200 / chgeff));
			model.add(Pdis[t] <= ((1 - Psoc[t - 1]) * 200 )* diseff);
		}



	

	}

	// Non-Negativity
	for (int t = 0; t < T; t++) {
		model.add(Pgridbuy[t] >= 0);
		model.add(Pgridsell[t] >= 0);
		model.add(Pch[t] >= 0);
		model.add(Pdis[t] >= 0);
		//model.add(Psoc[t] >= 0);
	}


#pragma endregion



		#pragma region Solve

	IloCplex cplex(model);
	cplex.setOut(env.getNullStream());
	cplex.setWarning(env.getNullStream());
	cplex.solve();

	//print status
	env.out() << "Solution status: " << cplex.getStatus() << endl;

	#pragma endregion


	#pragma region Print Results

	cout << "Objective Value: " << cplex.getObjValue() << endl;


	cout << "Pgridbuy\tPgridsell\tPrdg" << endl;

	for (int t = 0; t < 24; t++)
	{

		cout << cplex.getValue(Pch[t]) << "\t" << cplex.getValue(Pdis[t]) << "\t" << Rdg1[t] << "\t" << Eload[t] << endl;

	}


	return -1;
}