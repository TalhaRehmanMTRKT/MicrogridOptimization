#include <ilcplex/ilocplex.h>
#include<chrono>
#include <iostream>
#include <fstream>
#include <map>
ILOSTLBEGIN


typedef IloArray<IloNumVarArray> NumVar2D;
typedef IloArray<NumVar2D> NumVar3D;


int
main(int, char**)
{

#pragma region Input Data and constants

    int T = 24; //One day
    int NumEvs = 5; // Total Nmber of Electric vehicles
    int NumMg = 3; // Total Nmber of Microgrids
    int NumDg = 3; // Total Nmber of Diesel Generators
    int NumCHP = 3; // Total Nmber of Combine heat and power generation units
    int NumHOB = 1; // Total Number of Heat only boilers


    int** Cchp = new int* [NumMg];// add the randomly populating
    int** Cdg = new int* [NumMg];// add the randomly populating
    int** Chob = new int* [NumMg];// add the randomly populating
    int** k_chp = new int* [NumMg]; // add the randomly populating




    // Arrival and Departure time of Evs 
    int** ta = new int* [NumMg];  // add the randomly populating
    int** td = new int* [NumMg];  // add the randomly populating
    float** evsocini = new float* [NumMg];  // add the randomly populating
    float* socini = new float[NumMg];  // add the randomly populating
    float** evcap = new float* [NumMg]; // add the randomly populating 
    float** eveffin = new float* [NumMg]; // add the randomly populating 
    
    float* Heffin = new float[NumMg]; // add the randomly populating
    float* effin = new float [NumMg]; // add the randomly populating
    int* Hsscap = new int[NumMg] {}; // add the randomly populating 
    int* Bsscap = new int[NumMg] {}; // add the randomly populating 

    int** dgcap = new int* [NumMg]; // add the randomly populating 
    int** chpcap = new int* [NumMg]; // add the randomly populating 
    int** hobcap = new int* [NumMg]; // add the randomly populating 


    int** dgmin = new int* [NumMg]; // add the randomly populating 
    int** chpmin = new int* [NumMg]; // add the randomly populating 
    int** hobmin = new int* [NumMg]; // add the randomly populating 

    // Electric, Heat and Cooling Demand  // add the randomly populating 
    int** Pload = new int* [NumMg];  //Electicity demand w
    int** Hload = new int* [NumMg];  //Heat Demand
    int** Cload = new int* [NumMg];  //Cooling Demand

    // Renewable Infeeds  // Make the Scenario(Random) Generator for this
    float** Rdg = new float* [NumMg]; //Power generated by PV w.r.t time



    // Trading Prices Electric and Heat
    int* CGbuy = new int[T] { 138, 139, 143, 149, 150, 152, 155, 158, 160, 154, 153, 153, 152, 150, 149, 149, 154, 156, 163, 164, 164, 160, 150, 148};  //buying price of electricity
    int* CGsell = new int[T] { 128, 129, 133, 139, 140, 142, 145, 148, 150, 144, 143, 143, 142, 140, 139, 139, 144, 146, 153, 154, 154, 150, 140, 138}; //selling price of electricity
    int* CHbuy = new int[T] {77, 77, 77, 77, 77, 77, 77, 77, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 78, 78, 78, 78, 78, 78}; // buying price of heat
    int* CHsell = new int[T] {75, 75, 75, 75, 75, 75, 75, 75, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 78, 78, 78, 78, 78, 78 }; // selling price of heat


#pragma endregion


    IloEnv env;
    IloModel model(env);


#pragma region Decision Variables

    /// Electric Network Elements ///
//Gensets
    NumVar3D powerdg(env, NumMg);
    NumVar3D powerchp(env, NumMg);

    //Electric Battery
    NumVar2D BssSOC(env, NumMg);
    NumVar2D Bsschg(env, NumMg);
    NumVar2D Bssdischg(env, NumMg);



    //Electric Vehicles
    NumVar3D evSOC(env, NumMg);
    NumVar3D evchg(env, NumMg);
    NumVar3D evdischg(env, NumMg);


    //Electric Surplus and Shortage
    NumVar2D psur(env, NumMg);
    NumVar2D pshort(env, NumMg);


    /// Heat Network Elements ///

// Thermal Gensets
    NumVar3D heatchp(env, NumMg);
    NumVar3D heathob(env, NumMg);

    // Thermal storage system
    NumVar2D HssSOC(env, NumMg);
    NumVar2D Hsschg(env, NumMg);
    NumVar2D Hssdischg(env, NumMg);



    //Electric Surplus and Shortage
    NumVar2D Hsur(env, NumMg);
    NumVar2D Hshort(env, NumMg);

    /// Cooling Network Elements ///

// Cooling energy Gensets
    NumVar2D powerEC(env, NumMg);
    NumVar2D heatAC(env, NumMg);


    /// Grid Elements ///

//Electric power buy and sell
    NumVar2D powergridbuy(env, NumMg);
    NumVar2D powergridsell(env, NumMg);

    //Thermal power buy and sell
    NumVar2D heatgridbuy(env, NumMg);
    NumVar2D heatgridsell(env, NumMg);


    /// Internal microgrid trading Elements ///

    NumVar3D powersend(env, NumMg);
    NumVar3D powersrec(env, NumMg);
    NumVar3D heatsend(env, NumMg);
    NumVar3D heatrec(env, NumMg);


    /// Populating the Decision Varaibales 2D and 3D arrays ///

    for (int mg = 0; mg < NumMg; mg++)
    {

        powerEC[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        heatAC[mg] = IloNumVarArray(env, T, 0, IloInfinity);

        powergridbuy[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        powergridsell[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        heatgridbuy[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        heatgridsell[mg] = IloNumVarArray(env, T, 0, IloInfinity);

        HssSOC[mg] = IloNumVarArray(env, T, 0, 1);;
        Hsschg[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        Hssdischg[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        BssSOC[mg] = IloNumVarArray(env, T, 0, 1);
        Bsschg[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        Bssdischg[mg] = IloNumVarArray(env, T, 0, IloInfinity);

        psur[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        pshort[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        Hsur[mg] = IloNumVarArray(env, T, 0, IloInfinity);
        Hshort[mg] = IloNumVarArray(env, T, 0, IloInfinity);



        powerdg[mg] = NumVar2D(env, NumDg);

        for (int dg = 0; dg < NumDg; dg++)
        {
            powerdg[mg][dg] = IloNumVarArray(env, T, dgmin[mg][dg], dgcap[mg][dg]);
        }


        powerchp[mg] = NumVar2D(env, NumCHP);
        heatchp[mg] = NumVar2D(env, NumCHP);

        for (int chp = 0; chp < NumCHP; chp++)
        {
            powerchp[mg][chp] = IloNumVarArray(env, T, chpmin[mg][chp], dgcap[mg][chp]);
            heatchp[mg][chp] = IloNumVarArray(env, T, 0, IloInfinity); // Recheck to add the limit here in addition to the constraints
        }

        heathob[mg] = NumVar2D(env, NumHOB);
        for (int hob = 0; hob < NumHOB; hob++)
        {
            powerchp[mg][hob] = IloNumVarArray(env, T, hobmin[mg][hob], hobcap[mg][hob]);
        }


        evSOC[mg] = NumVar2D(env, NumEvs);
        evchg[mg] = NumVar2D(env, NumEvs);
        evdischg[mg] = NumVar2D(env, NumEvs);

        for (int ev = 0; ev < NumEvs; ev++)
        {
            evSOC[mg][ev] = IloNumVarArray(env, T, 0, 1);
            evchg[mg][ev] = IloNumVarArray(env, T, 0, evcap[mg][ev]);
            evdischg[mg][ev] = IloNumVarArray(env, T, 0, evcap[mg][ev]);
        }

        powersend[mg] = NumVar2D(env, NumMg);;
        powersrec[mg] = NumVar2D(env, NumMg);;
        heatsend[mg] = NumVar2D(env, NumMg);;
        heatrec[mg] = NumVar2D(env, NumMg);;



        for (int mgl = 0; mgl < NumMg; mgl++)
        {
            powersend[mg][mgl] = IloNumVarArray(env, T, 0, IloInfinity);
            powersrec[mg][mgl] = IloNumVarArray(env, T, 0, IloInfinity);
            heatsend[mg][mgl] = IloNumVarArray(env, T, 0, IloInfinity);
            heatrec[mg][mgl] = IloNumVarArray(env, T, 0, IloInfinity);
        }

    }

#pragma endregion



#pragma region Objective Function

    IloExpr objective(env);


    for (int t = 0; t < T; t++)
    {

        IloExpr exp0(env);
        IloExpr exp1(env);
        IloExpr exp2(env);
        IloExpr exp3(env);

        IloExpr exp4(env);
        IloExpr exp5(env);
        IloExpr exp6(env);

        for (int mg = 0; mg < NumMg; mg++)
        {
            exp0 += powergridbuy[mg][t];
            exp1 += powergridsell[mg][t];
            exp2 += heatgridbuy[mg][t];
            exp3 += heatgridsell[mg][t];

            for (int dg = 0; dg < NumDg; dg++)
            {
                exp4 += Cdg[mg][dg] * powerdg[mg][dg][t];
            }

            for (int chp = 0; chp < NumCHP; chp++)
            {
                exp5 += Cchp[mg][chp] * powerchp[mg][chp][t];
            }

            for (int hob = 0; hob < NumHOB; hob++)
            {
                exp6 += Chob[mg][hob] * powerchp[mg][hob][t];
            }



        }

        objective += CGbuy[t] * exp0 - CGsell[t] * exp1 + CHbuy[t] * exp2 - CHsell[t] * exp3 + exp4 + exp5 + exp6;


    }

    model.add(IloMinimize(env, objective));

#pragma endregion


#pragma region constraints



    for (int t = 0; t < T; t++)
    {



        for (int mg = 0; mg < NumMg; mg++)
        {
            for (int dg = 0; dg < NumDg; dg++)
            {
                model.add(dgmin[mg][dg] <= powerdg[mg][dg][t]);
                model.add(powerdg[mg][dg][t] <= dgcap[mg][dg]);
            }


            for (int chp = 0; chp < NumCHP; chp++)
            {
                model.add(chpmin[mg][chp] <= powerchp[mg][chp][t]);
                model.add(powerchp[mg][chp][t] <= chpcap[mg][chp]);
                model.add(heatchp[mg][chp][t] == k_chp[mg][chp] * powerchp[mg][chp][t]);
            }

            for (int hob = 0; hob < NumHOB; hob++)
            {
                model.add(hobmin[mg][hob] <= heathob[mg][hob][t]);
                model.add(heathob[mg][hob][t] <= hobcap[mg][hob]);
            }



            for (int n = 0; n < NumEvs; n++)
            {

                // soc bounds
                model.add(0 <= evSOC[mg][n][t]);
                model.add(evSOC[mg][n][t] <= 1);

                // Ev battery Constraints
                if (t == ta[mg][n])
                {
                    model.add(evSOC[mg][n][t] == evsocini[mg][n] + (eveffin[mg][n] * evchg[mg][n][t] - evdischg[mg][n][t] / eveffin[mg][n]) / evcap[mg][n]);
                    model.add(0 <= evchg[mg][n][t]);
                    model.add(0 <= evdischg[mg][n][t]);
                    model.add(evchg[mg][n][t] <= (evcap[mg][n] * (1 - evsocini[mg][n]) / eveffin[mg][n]));
                    model.add(evdischg[mg][n][t] <= (evcap[mg][n] * evsocini[mg][n] * eveffin[mg][n]));
                }
                else if (t > ta[mg][n] && t <= td[mg][n])

                {
                    model.add(evSOC[mg][n][t] == evSOC[mg][n][t-1] + ((eveffin[mg][n] * evchg[mg][n][t] - (evdischg[mg][n][t] / eveffin[mg][n])) / evcap[mg][n]));
                    model.add(0 <= evchg[mg][n][t]);
                    model.add(0 <= evdischg[mg][n][t]);
                    model.add(evchg[mg][n][t] <= (evcap[mg][n] * (1 - evSOC[mg][n][t-1])) / eveffin[mg][n]);
                    model.add(evdischg[mg][n][t] <= evcap[mg][n] * evSOC[mg][n][t-1] * eveffin[mg][n]);


                if (t == td[mg][n]) { model.add(evSOC[mg][n][t] >= 0.5); }

                }
                else
                {

                    model.add(evchg[mg][n][t] == 0);
                    model.add(evdischg[mg][n][t] == 0);

                }

            }

           


            // Adding the HSS and BSS Constraints constraints
            model.add(0 <= BssSOC[mg][t]);
            model.add(BssSOC[mg][t] <= 1);
            model.add(0 <= HssSOC[mg][t]);
            model.add(HssSOC[mg][t] <= 1);

            if (t == 0)
            {
                model.add(BssSOC[mg][t] == socini[mg] + ((effin[mg]  * Bsschg[mg][t] - (Bssdischg[mg][t] / effin[mg])) / Bsscap[mg]));
                model.add(0 <= Bsschg[mg][t]);
                model.add(0 <= Bssdischg[mg][t]);
                model.add(Bsschg[mg][t] <= (Bsscap[mg] * (1 - socini[mg]) / effin[mg]));
                model.add(Bssdischg[mg][t] <= (Bsscap[mg] * socini[mg] * effin[mg]));


                model.add(HssSOC[mg][t] == 0.5 + ((Heffin[mg] * Hsschg[mg][t] - (Hssdischg[mg][t] / Heffin[mg])) / Hsscap[mg]));
                model.add(0 <= Hsschg[mg][t]);
                model.add(0 <= Hssdischg[mg][t]);
                model.add(Hsschg[mg][t] <= (Hsscap[mg] * (1 - 0.5) / Heffin[mg]));
                model.add(Hssdischg[mg][t] <= (Hsscap[mg] * 0.5 * Heffin[mg]));

            }
            else
            {
                model.add(BssSOC[mg][t] == BssSOC[mg][t-1] + ((effin[mg] * Bsschg[mg][t] - (Bssdischg[mg][t] / effin[mg])) / Bsscap[mg]));
                model.add(0 <= Bsschg[mg][t]);
                model.add(0 <= Bssdischg[mg][t]);
                model.add(Bsschg[mg][t] <= (Bsscap[mg] * (1 - BssSOC[mg][t - 1])) / effin[mg]);
                model.add(Bssdischg[mg][t] <= Bsscap[mg] * BssSOC[mg][t - 1] * effin[mg]);


                model.add(HssSOC[mg][t] == HssSOC[mg][t - 1] + ((Heffin[mg] * Hsschg[mg][t] - (Hssdischg[mg][t] / Heffin[mg])) / Hsscap[mg]));
                model.add(0 <= Hsschg[mg][t]);
                model.add(0 <= Hssdischg[mg][t]);
                model.add(Hsschg[mg][t] <= (Hsscap[mg] * (1 - HssSOC[mg][t - 1]) / Heffin[mg]));
                model.add(Hssdischg[mg][t] <= (Hsscap[mg] * HssSOC[mg][t - 1] * Heffin[mg]));
            }


            // Preparing electric vehicles expression for the power balance equation
            IloExpr exp0(env);
            IloExpr exp1(env);
            for (int n = 0; n < NumEvs; n++)
            {
                exp0 += evchg[mg][n][t];
                exp1 += evdischg[mg][n][t];
            }
            IloExpr dgpsum(env);
            for (int dg = 0; dg < NumDg; dg++)
            {
                dgpsum += powerdg[mg][dg][t];
            }
            IloExpr chpEsum(env);
            IloExpr chpHsum(env);
            for (int chp = 0; chp < NumCHP; chp++)
            {
                chpEsum += powerchp[mg][chp][t];
                chpHsum += heatchp[mg][chp][t];

            }
            IloExpr hobsum(env);
            for (int hob = 0; hob < NumHOB; hob++)
            {
                hobsum += heathob[mg][hob][t];
            }


            // Adding the Electric power balance constraint

            model.add(dgpsum - powerEC[mg][t] + Rdg[mg][t] + chpEsum + Bssdischg[mg][t] + powergridbuy[mg][t]  + exp1 - exp0 - Bsschg[mg][t]  - powergridsell[mg][t] == Pload[mg][t]);

            model.add(hobsum - heatAC[mg][t] + chpHsum +heatgridbuy[mg][t] - heatgridsell[mg][t] - Hsschg[mg][t] + Hssdischg[mg][t] == Hload[mg][t]);

            model.add(0.85 * heatAC[mg][t] + 0.95 * powerEC[mg][t] == Cload[mg][t]);


        }

    }






    IloExpr exp0(env);
    IloExpr exp1(env);
    IloExpr exp2(env);
    IloExpr exp3(env);

    for (int k = 0; k < NumMg; k++)
    {
        for (int l = 0; l < NumMg; l++)
        {

            if (k != l) {

                for (int t = 0; t < T; t++)
                {
                    exp0 += powersend[k][l][t];
                    exp1 += powersrec[k][l][t];
                    exp2 += heatsend[k][l][t];
                    exp3 += heatrec[k][l][t];
                }

            }
            else
            {
                for (int t = 0; t < T; t++)
                {
                    model.add(powersend[k][l][t] == 0);
                    model.add(powersrec[k][l][t] == 0);
                    model.add(heatsend[k][l][t] == 0);
                    model.add(heatrec[k][l][t] == 0);
                }
            }
        }
    }
    model.add(exp0 == exp1);
    model.add(exp2 == exp3);

    for (int t = 0; t < T; t++)
    {

        for (int k = 0; k < NumMg; k++)
        {
            IloExpr mgEsend(env);
            IloExpr mgErec(env);
            IloExpr mgHsend(env);
            IloExpr mgHrec(env);

            for (int l = 0; l < NumMg; l++)
            {
                mgEsend += powersend[k][l][t];
                mgErec += powersrec[k][l][t];
                mgHsend += heatsend[k][l][t];
                mgHrec += heatrec[k][l][t];
            }
            model.add(mgEsend + powergridsell[k][t] == psur[k][t]);
            model.add(mgHsend + heatgridsell[k][t] == Hsur[k][t]);
            model.add(mgErec + powergridbuy[k][t] == pshort[k][t]);
            model.add(mgHrec + heatgridbuy[k][t] == Hshort[k][t]);
        }
    }

#pragma endregion



#pragma endregion
    IloCplex cplex(env);
    cplex.extract(model);
    cplex.exportModel("ModelLP.lp");
    cplex.setOut(env.getNullStream());
    cplex.solve();
    double obj = cplex.getObjValue();
    cout << "Solution status: " << cplex.getStatus() << endl;
    cout << "Minimized Objective Funtion of " << obj << endl;

    return 1;

}