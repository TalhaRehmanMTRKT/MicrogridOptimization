#include <ilcplex/ilocplex.h>
#include<chrono>
#include <iostream>
#include <fstream>
ILOSTLBEGIN


int
main(int, char**)
{

    auto start = chrono::high_resolution_clock::now();
    IloEnv env;
    IloModel model(env);


#pragma region Microgrid Input Data


int T = 24; //One day
int Cdg1 = 150; //Cost for generating per kW power from dg
int Cdg2 = 150; //Cost for generating per kW power from dg
int Cdg3 = 150; //Cost for generating per kW power from dg

int* Pload = new int[T] {750, 753, 773, 753, 760, 784, 801, 944, 1039, 1094, 1094, 1125, 1094, 1080, 1073, 1084, 1063, 1063, 1084, 1084, 1012, 992, 961, 923};  //Electicity demand w.r.t tim

float* CGbuy = new float[T] {2.239, 2.059, 1.681, 1.741, 1.702, 1.586, 1.816, 1.773, 1.977, 2.375, 2.603, 2.706, 2.659, 2.5, 2.443, 2.887, 3.744, 3.741, 3.534, 3.307, 2.952, 3.01, 2.457, 2.22
    };  //buying price from grid w.r.t time
//int* CGsell = new int[T] { 70, 70, 70, 70, 70, 70, 90, 90, 90, 90, 90, 105, 105, 105, 105, 105, 105, 105, 90, 90, 90, 90, 90, 90}; //selling price to grid w.r.t time

float* Rdg1 = new float[T] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 27.9427430371824, 78.4171855825344, 119.9574832587936, 144.47673745704003, 170.46136549534558, 154.4519805549984, 128.35401718045438, 86.2843762183104, 37.7743455547104, 4.00110414396, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
    }; //Power generated by PV w.r.t time
//float* Rdg2 = new float[T] {1230.0, 4215.0, 5243.0, 3526.0, 45420.0, 3526.0, 3256.0, 3242, 2363, 2012, 2345, 2831, 3312, 3525, 3456, 3121, 2856, 1650, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }; //Power generated by PV w.r.t time


float socini = 0.4; //Initially charged battery
int Pbmax = 500; //battery maximum capacity
float effin = 0.95; //battery effciency

#pragma endregion


#pragma region Decision Variables
IloNumVarArray PGbuy(env, T, 0, IloInfinity);//Grid power bought
IloNumVarArray PGsell(env, T, 0, IloInfinity);//Grid power sold

IloNumVarArray statoc(env, T, 0, 1); //battery storage capacity

IloNumVarArray Bchg(env, T, 0, 100); //battery charging
IloNumVarArray Bdischg(env, T, 0, 100); //battery discharging

IloNumVarArray Pdg1(env, T, 0, 500); //DGA power generation range
IloNumVarArray Pdg2(env, T, 0, 375); //DGA power generation range
IloNumVarArray Pdg3(env, T, 0, 500); //DGA power generation range
#pragma endregion


#pragma region Objective Function

IloExpr objective(env, T);

 
    for (int t = 0; t < T; t++)
    {
        objective +=  Cdg1 * Pdg1[t] + Cdg3 * Pdg3[t] + Cdg2 * Pdg2[t] + CGbuy[t] * PGbuy[t] - 0.5 * CGbuy[t] * PGsell[t];

    }


    // Objective: minimize cost
    model.add(IloMinimize(env, objective));

#pragma endregion



#pragma region Constraints


    // Constraint: meet demand

    for (int t = 0; t < T; t++)
    {

        model.add(0 <= Pdg1[t]);
        model.add(Pdg1[t] <= 500);

        model.add(0 <= Pdg2[t]);
        model.add(Pdg2[t] <= 375);        
        model.add(0 <= Pdg3[t]);
        model.add(Pdg3[t] <= 500);
        model.add(PGbuy[t] <= 500);
        model.add(PGsell[t] <= 500);


        // Adding the Battery Constraints constraints
        model.add(0.1 <= statoc[t]);
        model.add(statoc[t] <= 0.9);
        if (t == 0)
        {
            model.add(statoc[t] == socini + ((effin * Bchg[t] - (Bdischg[t] / effin)) / Pbmax));
            model.add(0 <= Bchg[t]);
            model.add(0 <= Bdischg[t]);
            model.add(Bchg[t] <= (Pbmax * (1 - socini) / effin));
            model.add(Bdischg[t] <= (Pbmax * socini * effin));


        }
        else
        {
            model.add(statoc[t] == statoc[t - 1] + ((effin * Bchg[t] - (Bdischg[t] / effin)) / Pbmax));
            model.add(0 <= Bchg[t]);
            model.add(0 <= Bdischg[t]);
            model.add(Bchg[t] <= (Pbmax * (1 - statoc[t - 1])) / effin);
            model.add(Bdischg[t] <= Pbmax * statoc[t - 1] * effin);

        }

        // Adding the power balance constraint
        model.add(Pdg1[t] + Pdg2[t] + Pdg3[t] + Rdg1[t] + Bdischg[t] - Bchg[t] + PGbuy[t] - PGsell[t] == Pload[t]);
    }

#pragma endregion


#pragma region Results
    IloCplex cplex(env);
    cplex.extract(model);
    cplex.exportModel("ModelLP.lp");
    cplex.setOut(env.getNullStream());
    if (!cplex.solve()) {
        env.error() << "Failed" << endl;
        throw(-1);
    }
    double obj = cplex.getObjValue();
    auto end = chrono::high_resolution_clock::now();
    auto Elapsed = chrono::duration_cast<chrono::milliseconds>(end - start);
    cout << "\n\n\t The elapsed time is: \t" << Elapsed.count() << endl;
    cout << "Solution status: " << cplex.getStatus() << endl;
    cout << "Minimized Objective Funtion : " << obj << endl;
    IloNum eps = cplex.getParam(
        IloCplex::Param::MIP::Tolerances::Integrality);
#pragma endregion


#pragma region StoringOutput

    // Create and open the CSV file for writing
    std::ofstream outputFile("output.csv");

    if (outputFile.is_open()) {
        // Write the header row
        outputFile << "Time,Pload,CGbuy,CGsell,Rdg1,Rdg2,PGbuy,PGsell,statoc,Bchg,Bdischg,Pdg1,Pdg2" << std::endl;

        // Write the data rows
        for (int i = 0; i < T; i++) {
            outputFile << i + 1 << "," << Pload[i] << "," << CGbuy[i] << ","
                << CGsell[i] << "," << Rdg1[i] << "," 
                << cplex.getValue(PGbuy[i]) << "," << -cplex.getValue(PGsell[i]) << ","
                << cplex.getValue(statoc[i]) << "," << -cplex.getValue(Bchg[i]) << ","
                << cplex.getValue(Bdischg[i]) << "," << cplex.getValue(Pdg1[i]) << ","
                << cplex.getValue(Pdg2[i]) << std::endl;
        }

        // Close the CSV file
        outputFile.close();
        std::cout << "Data saved to output.csv" << std::endl;
    }
    else {
        std::cerr << "Failed to open the output.csv file for writing." << std::endl;
    }


#pragma endregion

    env.end();
    system("pause");
    return 0;
}