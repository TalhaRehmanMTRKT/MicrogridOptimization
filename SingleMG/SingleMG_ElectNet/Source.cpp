#include <ilcplex/ilocplex.h>
#include<chrono>
#include <iostream>
#include <fstream>
ILOSTLBEGIN


int
main(int, char**)
{

    auto start = chrono::high_resolution_clock::now();
    IloEnv env;
    IloModel model(env);


#pragma region Microgrid Input Data


    int T = 24; //One day
    int Cdg1 = 80; //Cost for generating per kW power from dg
    int Cdg2 = 90; //Cost for generating per kW power from dg

    int* Pload = new int[T] {169, 175, 179, 171, 181, 172, 270, 264, 273, 281, 193, 158, 161, 162, 250, 260, 267, 271, 284, 167, 128, 134, 144, 150};  //Electicity demand w.r.t tim

    int* CGbuy = new int[T] { 90, 90, 90, 90, 90, 90, 110, 110, 110, 110, 110, 125, 125, 125, 125, 125, 125, 125, 110, 110, 110, 110, 110, 110 };  //buying price from grid w.r.t time
    int* CGsell = new int[T] { 70, 70, 70, 70, 70, 70, 90, 90, 90, 90, 90, 105, 105, 105, 105, 105, 105, 105, 90, 90, 90, 90, 90, 90}; //selling price to grid w.r.t time

    float* Rdg1 = new float[T] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 15, 20, 23, 28, 33, 35, 34, 31, 28, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }; //Power generated by PV w.r.t time
    float* Rdg2 = new float[T] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10, 15, 20, 23, 28, 33, 35, 34, 31, 28, 10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }; //Power generated by PV w.r.t time


    float socini = 0.2; //Initially charged battery
    int Pbmax = 200; //battery maximum capacity
    float effin = 0.95; //battery effciency

#pragma endregion


#pragma region Decision Variables
    IloNumVarArray PGbuy(env, T, 0, IloInfinity);//Grid power bought
    IloNumVarArray PGsell(env, T, 0, IloInfinity);//Grid power sold

    IloNumVarArray statoc(env, T, 0, 1); //battery storage capacity

    IloNumVarArray Bchg(env, T, 0, 100); //battery charging
    IloNumVarArray Bdischg(env, T, 0, 100); //battery discharging

    IloNumVarArray Pdg1(env, T, 0, 80); //DGA power generation range
    IloNumVarArray Pdg2(env, T, 0, 100); //DGA power generation range
#pragma endregion


#pragma region Objective Function

    IloExpr objective(env, T);


    for (int t = 0; t < T; t++)
    {
        objective += Cdg1 * Pdg1[t] + Cdg2 * Pdg2[t] + CGbuy[t] * PGbuy[t] - CGsell[t] * PGsell[t];

    }


    // Objective: minimize cost
    model.add(IloMinimize(env, objective));

#pragma endregion



#pragma region Constraints


    // Constraint: meet demand

    for (int t = 0; t < T; t++)
    {

        model.add(0 <= Pdg1[t]);
        model.add(Pdg1[t] <= 80);

        model.add(0 <= Pdg2[t]);
        model.add(Pdg2[t] <= 90);



        // Adding the Battery Constraints constraints
        model.add(0 <= statoc[t]);
        model.add(statoc[t] <= 1);
        if (t == 0)
        {
            model.add(statoc[t] == socini + ((effin * Bchg[t] - (Bdischg[t] / effin)) / Pbmax));
            model.add(0 <= Bchg[t]);
            model.add(0 <= Bdischg[t]);
            model.add(Bchg[t] <= (Pbmax * (1 - socini) / effin));
            model.add(Bdischg[t] <= (Pbmax * socini * effin));


        }
        else
        {
            model.add(statoc[t] == statoc[t - 1] + ((effin * Bchg[t] - (Bdischg[t] / effin)) / Pbmax));
            model.add(0 <= Bchg[t]);
            model.add(0 <= Bdischg[t]);
            model.add(Bchg[t] <= (Pbmax * (1 - statoc[t - 1])) / effin);
            model.add(Bdischg[t] <= Pbmax * statoc[t - 1] * effin);

        }

        // Adding the power balance constraint
        model.add(Pdg1[t] + Pdg2[t] + Rdg1[t] + Rdg2[t] + Bdischg[t] - Bchg[t] + PGbuy[t] - PGsell[t] == Pload[t]);
    }

#pragma endregion


#pragma region Results
    IloCplex cplex(env);
    cplex.extract(model);
    cplex.exportModel("ModelLP.lp");
    cplex.setOut(env.getNullStream());
    if (!cplex.solve()) {
        env.error() << "Failed" << endl;
        throw(-1);
    }
    double obj = cplex.getObjValue();
    auto end = chrono::high_resolution_clock::now();
    auto Elapsed = chrono::duration_cast<chrono::milliseconds>(end - start);
    cout << "\n\n\t The elapsed time is: \t" << Elapsed.count() << endl;
    cout << "Solution status: " << cplex.getStatus() << endl;
    cout << "Minimized Objective Funtion : " << obj << endl;
    IloNum eps = cplex.getParam(
        IloCplex::Param::MIP::Tolerances::Integrality);
#pragma endregion


#pragma region StoringOutput

    // Create and open the CSV file for writing
    std::ofstream outputFile("output.csv");

    if (outputFile.is_open()) {
        // Write the header row
        outputFile << "Time,Pload,CGbuy,CGsell,Rdg1,Rdg2,PGbuy,PGsell,statoc,Bchg,Bdischg,Pdg1,Pdg2" << std::endl;

        // Write the data rows
        for (int i = 0; i < T; i++) {
            outputFile << i + 1 << "," << Pload[i] << "," << CGbuy[i] << ","
                << CGsell[i] << "," << Rdg1[i] << "," << Rdg2[i] << ","
                << cplex.getValue(PGbuy[i]) << "," << -cplex.getValue(PGsell[i]) << ","
                << cplex.getValue(statoc[i]) << "," << -cplex.getValue(Bchg[i]) << ","
                << cplex.getValue(Bdischg[i]) << "," << cplex.getValue(Pdg1[i]) << ","
                << cplex.getValue(Pdg2[i]) << std::endl;
        }

        // Close the CSV file
        outputFile.close();
        std::cout << "Data saved to output.csv" << std::endl;
    }
    else {
        std::cerr << "Failed to open the output.csv file for writing." << std::endl;
    }


#pragma endregion

    env.end();
    system("pause");
    return 0;
}